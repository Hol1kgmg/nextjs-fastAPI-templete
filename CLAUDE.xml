<?xml version="1.0" encoding="UTF-8"?>
<claude-instructions repository="sukima" version="1.0">
  
  <!-- Core Principles - Must be verified before every operation -->
  <core-principles>
    
    <principle id="japanese-communication" priority="critical">
      <title>Japanese Communication</title>
      <requirement>Claude Code must communicate in Japanese</requirement>
      <applies-to>
        <item>Commit messages</item>
        <item>Comments</item>
        <item>Error messages</item>
        <item>User interactions</item>
      </applies-to>
    </principle>

    <principle id="pre-approval" priority="critical">
      <title>Pre-approval Requirement</title>
      <requirement>Before creating, editing, or deleting files, always report and obtain explicit user approval</requirement>
      <must-report>
        <item>List of target files</item>
        <item>Detailed description of changes to be made</item>
        <item>Explanation of impact scope</item>
      </must-report>
    </principle>

    <principle id="decision-authority" priority="critical">
      <title>Decision Authority Principle</title>
      <rules>
        <rule>Final decision authority always belongs to the user</rule>
        <rule>AI must not arbitrarily choose alternative approaches or workarounds</rule>
        <rule>Always ask questions when uncertain, never proceed based on assumptions</rule>
      </rules>
    </principle>

    <principle id="compliance-verification" priority="high">
      <title>CLAUDE.md Compliance Verification</title>
      <requirement>Before starting work, verify compliance with relevant rules in this document and report this to the user</requirement>
    </principle>

  </core-principles>

  <!-- Standard Workflow - Execute for all tasks -->
  <workflow>
    <step number="1" id="task-understanding">
      <title>Task Understanding</title>
      <actions>
        <action>Clearly understand user requirements</action>
        <action>Ask questions if anything is unclear</action>
        <action>Confirm expected deliverables</action>
      </actions>
    </step>

    <step number="2" id="planning">
      <title>Planning</title>
      <actions>
        <action>Create detailed execution plan</action>
        <action>Identify affected files and systems</action>
        <action>Assess risks and considerations</action>
      </actions>
    </step>

    <step number="3" id="pre-reporting">
      <title>Pre-reporting</title>
      <actions>
        <action>Report plan to user</action>
        <action>Obtain explicit approval</action>
        <action critical="true">Do not execute without approval</action>
      </actions>
    </step>

    <step number="4" id="execution">
      <title>Execution</title>
      <actions>
        <action>Execute according to plan</action>
        <action>Report unexpected situations immediately</action>
        <action critical="true">Do not make independent decisions</action>
      </actions>
    </step>

    <step number="5" id="completion-report">
      <title>Completion Report</title>
      <actions>
        <action>Report execution results in detail</action>
        <action>Request confirmation of changes</action>
        <action>Confirm next actions</action>
      </actions>
    </step>
  </workflow>

  <!-- Mandatory Checklists -->
  <checklists>
    
    <checklist id="file-operations" title="Before File Operations">
      <item>Verified relevant CLAUDE.md rules</item>
      <item>Understood current state of target files</item>
      <item>Identified scope of impact from changes</item>
      <item>Obtained explicit user approval</item>
      <item>Considered backup and recovery methods</item>
    </checklist>

    <checklist id="code-generation" title="Before Code Generation/Editing">
      <item>Verified project naming conventions</item>
      <item>Understood existing code style</item>
      <item>Verified dependencies and tech stack</item>
      <item>Confirmed testing and quality requirements</item>
    </checklist>

    <checklist id="git-operations" title="Before Git Operations">
      <item>Confirmed changes are as intended</item>
      <item>Verified commit message guidelines</item>
      <item>Understood branching strategy</item>
      <item>Performed final verification before push</item>
    </checklist>

  </checklists>

  <!-- Development Commands -->
  <development-commands>
    
    <core-commands>
      <command name="dev">bun run dev - Start development server (Next.js)</command>
      <command name="build">bun run build - Build production application</command>
      <command name="start">bun run start - Start production server</command>
      <command name="typecheck">bun run typecheck - Type check with TypeScript</command>
    </core-commands>

    <quality-commands>
      <command name="check">bun run check - Run Biome linter and formatter checks</command>
      <command name="check-fix">bun run check:fix - Run Biome with auto-fix (includes unsafe fixes)</command>
      <command name="format">bun run format - Check formatting with Biome</command>
      <command name="format-fix">bun run format:fix - Auto-format code with Biome</command>
    </quality-commands>

    <testing-commands>
      <command name="test">bun run test - Run tests with Vitest once and exit (use this instead of `bun test`)</command>
    </testing-commands>

    <code-analysis-commands>
      <command name="similarity">similarity-ts . - Detect duplicate functions and similar code patterns across codebase</command>
    </code-analysis-commands>

    <git-hooks>
      <hook type="pre-commit">Automatically runs `bun run check:fix` and stages fixed files</hook>
      <hook type="pre-push">Runs `bun run check` and `bun run typecheck` before pushing</hook>
    </git-hooks>

  </development-commands>

  <!-- Tech Stack -->
  <architecture>
    <tech-stack>
      <framework>Next.js 15 with App Router</framework>
      <language>TypeScript</language>
      <styling>Tailwind CSS v4</styling>
      <ui-components>shadcn/ui with Radix UI primitives</ui-components>
      <code-quality>Biome for linting and formatting</code-quality>
      <git-hooks>Lefthook</git-hooks>
    </tech-stack>

    <project-structure>
      <directory path="src/app/">Next.js App Router</directory>
      <directory path="src/components/ui/">shadcn/ui components</directory>
      <directory path="src/components/shared/">Reusable components across features</directory>
      <directory path="src/components/features/">Screen/page-specific components with feature-specific logic</directory>
      <directory path="src/lib/">Global utility functions</directory>
      <directory path="src/hooks/">Global custom hooks</directory>
    </project-structure>
    
    <package-by-feature>
      <principle>Group related code by feature rather than by technical type</principle>
      <global-locations>
        <location>src/lib/ - Utilities used across multiple features</location>
        <location>src/hooks/ - Hooks used across multiple features</location>
      </global-locations>
      <feature-locations>
        <location>Feature directories - Business logic, hooks, types specific to that feature</location>
        <location>Component directories - Logic specific to that component</location>
      </feature-locations>
    </package-by-feature>
  </architecture>

  <!-- Component Naming Conventions -->
  <component-naming-conventions>
    
    <strict-rules>
      <rule>Directory names: kebab-case</rule>
      <rule>TSX file names: PascalCase</rule>
      <rule>TS file names: camelCase (for utility functions, helpers, types, etc.)</rule>
      <rule>Component names: PascalCase (matches file name exactly)</rule>
      <rule>Directory and file names must correspond: kebab-case → PascalCase conversion</rule>
      <rule>No barrel files (index.ts) - use direct imports only</rule>
      <rule>Import paths: Use absolute paths with @/ alias, not relative paths</rule>
    </strict-rules>

    <matching-rules>
      <rule>Directory name and TSX file name must match (kebab-case → PascalCase conversion)</rule>
      <rule>TSX file name and component name must be identical</rule>
      <rule>If directory name and TSX file name don't match, create a new directory</rule>
    </matching-rules>

    <examples>
      <correct-structure>
        <directory name="videos">Videos.tsx (export function Videos())</directory>
        <directory name="empty-state">EmptyState.tsx (export function EmptyState())</directory>
      </correct-structure>
      
      <conversion-table>
        <mapping directory="video-grid" file="VideoGrid.tsx" component="VideoGrid"/>
        <mapping directory="empty-state" file="EmptyState.tsx" component="EmptyState"/>
        <mapping directory="user-profile" file="UserProfile.tsx" component="UserProfile"/>
      </conversion-table>
    </examples>

    <directory-structure>
      <location path="ui/">shadcn/ui components only (flat naming: button.tsx, input.tsx)</location>
      <location path="shared/">Reusable components used across multiple features/screens</location>
      <location path="features/">Screen/page-specific components organized by feature area</location>
    </directory-structure>

    <creation-checklist>
      <item>Determine correct location: ui/ (shadcn/ui), shared/ (reusable), or features/ (screen-specific)</item>
      <item>Directory name is kebab-case (except for ui/ which uses flat naming)</item>
      <item>TSX file name is PascalCase (except for ui/ which uses flat naming)</item>
      <item>TS file name is camelCase (for utilities, helpers, types)</item>
      <item>Component name matches file name exactly</item>
      <item>Directory name converts to file name (kebab-case → PascalCase)</item>
      <item>Feature-specific logic stays within feature directory (Package by Feature)</item>
      <item>Global utilities only for truly generic functions</item>
      <item>No barrel files (index.ts) used</item>
      <item>Use absolute import paths with @/ alias, not relative paths</item>
      <item>Direct imports used for all components</item>
      <item>Avoid prop names that conflict with ARIA attributes (e.g., use avatarType instead of role)</item>
    </creation-checklist>

    <ai-agent-notes>
      <note>Always get user approval before creating, moving, or refactoring components</note>
      <note>Present a clear plan showing which naming rules apply and the exact file paths</note>
      <note>Verify naming consistency between directory, file, and component names before any file operations</note>
    </ai-agent-notes>

  </component-naming-conventions>

  <!-- General Naming Conventions -->
  <naming-conventions>
    
    <english-grammar-rules>
      <principle>Use natural English following proper grammar rules</principle>
      
      <basic-rules>
        <rule type="functions">Start with verbs (getUserById, isValid, canEdit)</rule>
        <rule type="variables">Use nouns (userId, totalPrice, isLoading)</rule>
        <rule type="components">Use nouns (UserProfile, NavigationMenu)</rule>
        <rule type="event-handlers">handle + event name (handleSubmit, handleClick)</rule>
      </basic-rules>

      <common-mistakes>
        <mistake type="missing-verbs">
          <wrong>function userById()</wrong>
          <correct>getUserById()</correct>
        </mistake>
        <mistake type="japanese-style">
          <wrong>const getUserInfo</wrong>
          <correct>getUserInformation</correct>
        </mistake>
        <mistake type="unnatural-order">
          <wrong>const usersActive</wrong>
          <correct>activeUsers</correct>
        </mistake>
      </common-mistakes>
    </english-grammar-rules>

    <abbreviation-rules>
      <principle>Avoid abbreviations, use full English words</principle>
      
      <basic-rules>
        <avoid-examples>
          <mapping short="bg" full="backgroundColor"/>
          <mapping short="prev" full="previous"/>
          <mapping short="btn" full="button"/>
        </avoid-examples>
        <acceptable>Only established technical terms (id, url, ref)</acceptable>
      </basic-rules>

      <acronym-casing-rules>
        <principle>In compound words, maintain the standard casing of acronyms</principle>
        <examples>
          <correct>generateURLParameter</correct>
          <correct>APIClient</correct>
          <correct>parseJWTToken</correct>
          <wrong>generateUrlParameter</wrong>
          <wrong>apiClient</wrong>
          <wrong>parseJwtToken</wrong>
        </examples>
      </acronym-casing-rules>
    </abbreviation-rules>

  </naming-conventions>

  <!-- Component Separation Guidelines -->
  <component-separation-guidelines>
    
    <core-principle>
      <title>Observability of Behavior</title>
      <description>The fundamental rule for component separation is whether "all behaviors can be observed." Length alone is not a criterion for separation. The key question is: Can you write tests for it? Is separation necessary to write proper tests?</description>
    </core-principle>

    <advanced-pattern>
      <title>Internal Visibility Control</title>
      <principle>Move conditional rendering logic inside components using isVisible prop instead of external conditional rendering</principle>
      
      <anti-pattern>
        <title>External Conditional Rendering</title>
        <description>Requires hook mocking to test conditional rendering</description>
      </anti-pattern>
      
      <recommended-pattern>
        <title>Internal Visibility Control</title>
        <description>Components control their own visibility via props</description>
        <implementation>
          <rule>Add isVisible prop to component interface</rule>
          <rule>Use early return pattern for visibility control</rule>
          <rule>Test visibility states directly via props</rule>
        </implementation>
      </recommended-pattern>
      
      <testing-benefits>
        <benefit>Eliminates need for hook mocking</benefit>
        <benefit>Enables direct prop-based testing</benefit>
        <benefit>Improves component isolation</benefit>
        <benefit>Ensures predictable behavior</benefit>
      </testing-benefits>
    </advanced-pattern>

    <function-extraction-pattern>
      <title>Complete Logic Extraction</title>
      <principle>Extract entire branching logic blocks as separate functions rather than just conditions</principle>
      
      <key-rules>
        <rule>Extract complete logic blocks, not just conditions</rule>
        <rule>Return structured results for testability</rule>
        <rule>Accept dependencies as parameters</rule>
        <rule>Use camelCase naming for function files</rule>
      </key-rules>
      
      <benefits>
        <benefit>Eliminates hook mocking in tests</benefit>
        <benefit>Enables pure function testing</benefit>
        <benefit>Improves logic reusability</benefit>
      </benefits>
    </function-extraction-pattern>

    <when-not-to-separate>
      <case>
        <title>Props-based Conditional Rendering</title>
        <description>If you have conditional rendering based on props that can be directly controlled</description>
        <recommendation>No need to separate - can test via Storybook stories with different props</recommendation>
      </case>
    </when-not-to-separate>

    <decision-framework>
      <question>Can I control this behavior via props?</question>
      <question>Is there external conditional rendering?</question>
      <question>Is there complex conditional logic with external state dependencies?</question>
      <question>Is there computation/processing before conditional rendering?</question>
      <question>Can I write meaningful tests for this part in isolation?</question>
      <question>Does this part have clear, single responsibility?</question>
      
      <guideline>Move external conditional rendering inside components as isVisible prop</guideline>
      <guideline>Extract complete logic blocks for complex conditional flows</guideline>
      <guideline>Separate computation logic from rendering components</guideline>
      <guideline>Prioritize testability and component isolation</guideline>
    </decision-framework>

  </component-separation-guidelines>

  <!-- Testing Guidelines -->
  <testing-guidelines>
    
    <test-simplicity>
      <principle>Keep tests simple and focused on essential conditional logic only</principle>
      <rules>
        <rule>Test only core branching logic - avoid over-testing edge cases</rule>
        <rule>Focus on essential conditions (e.g., Enter vs other keys, empty vs valid input)</rule>
        <rule>Remove unnecessary Act/Assert comments for simple tests</rule>
        <rule>Combine similar test cases when they test the same logical branch</rule>
      </rules>
    </test-simplicity>

    <arrange-act-assert>
      <description>All tests must follow the Arrange-Act-Assert pattern with specific variable naming</description>
      <rules>
        <rule>Single-level describe only - No nested describe blocks</rule>
        <rule>Use test() for individual test cases - Not it()</rule>
        <rule>One expect per test - Each test should verify exactly one thing</rule>
        <rule>Common data at describe level - Share setup data across tests</rule>
        <rule>Named variables: Use 'actual' for test results, 'expected' for expected values</rule>
      </rules>
    </arrange-act-assert>

    <anti-patterns>
      <pattern>Multiple expects testing side effects in one test</pattern>
      <pattern>Over-testing with redundant similar test cases</pattern>
      <pattern>Testing multiple branches of the same condition separately</pattern>
      <pattern>Including unnecessary Act/Assert comments</pattern>
    </anti-patterns>

  </testing-guidelines>

  <!-- Storybook Guidelines -->
  <storybook-guidelines>
    
    <story-creation-rules>
      <rule>Create stories for every visual variation controllable via props</rule>
      <rule>Single story for components with no visual variations</rule>
      <rule>Avoid stories for non-controllable branching (internal hooks, state)</rule>
      <rule>Avoid stories that show nothing (isVisible: false, empty states)</rule>
    </story-creation-rules>

    <avoid-non-visual-stories>
      <principle>Storybook is for visual confirmation, not logic testing</principle>
      <rules>
        <rule>Don't create stories for states that produce no visual output</rule>
        <rule>Use snapshot tests for non-visual logic testing instead</rule>
        <rule>Focus on meaningful visual variations only</rule>
      </rules>
      <examples>
        <avoid>Hidden stories with isVisible: false</avoid>
        <avoid>Empty state stories that show nothing</avoid>
        <avoid>Stories that render null or empty divs</avoid>
      </examples>
    </avoid-non-visual-stories>

    <meta-configuration>
      <principle>Keep meta configuration minimal</principle>
      <rules>
        <rule>Only add parameters, argTypes, and autoDocs when specific requirements demand it</rule>
        <rule>Basic meta should contain component and args (if needed)</rule>
        <rule>Use satisfies Meta&lt;typeof Component&gt; for type safety</rule>
      </rules>
    </meta-configuration>

    <event-handler-configuration>
      <principle>Use fn() function for event handlers in args property</principle>
      <rules>
        <rule>Import fn from 'storybook/test'</rule>
        <rule>Add event handlers like onClick: fn() to meta args</rule>
        <rule>Provides action logging in Storybook interface</rule>
      </rules>
    </event-handler-configuration>

  </storybook-guidelines>

  <!-- shadcn/ui Configuration -->
  <shadcn-ui-configuration>
    
    <setup>
      <style>New York variant</style>
      <base-color>Neutral</base-color>
      <css-variables>Enabled</css-variables>
      <rsc>React Server Components enabled</rsc>
      <icon-library>Lucide React</icon-library>
    </setup>

    <path-aliases>
      <alias from="@/components" to="src/components"/>
      <alias from="@/lib" to="src/lib"/>
      <alias from="@/utils" to="src/lib/utils"/>
      <alias from="@/ui" to="src/components/ui"/>
      <alias from="@/hooks" to="src/hooks"/>
    </path-aliases>

  </shadcn-ui-configuration>

</claude-instructions>